# 2025년 7월 7일 리팩토링 연습 요약

Gemini CLI와 함께 진행한 Python 코드 리팩토링 연습 내용을 아래와 같이 요약합니다.

## 1. 클래스 책임 분리 (단일 책임 원칙)

- **`refactor_todo_single_responsibility.py`**
  - **기존 코드**: `TodoManager` 클래스가 할 일 추가, 목록 보기, 파일 저장/불러오기 등 모든 기능을 담당했습니다.
  - **리팩토링**:
    - `TodoList` 클래스: 할 일 목록을 관리하는 책임만 담당합니다.
    - `FileManager` 클래스: 파일 읽기/쓰기를 책임지는 역할만 담당합니다.
  - **효과**: 각 클래스의 역할이 명확해지고, 코드를 이해하고 수정하기 쉬워졌습니다. 파일 저장 방식을 변경하더라도 `TodoList` 코드는 수정할 필요가 없어졌습니다.

## 2. 데이터와 기능의 결합 (객체 지향 생활 체조 원칙)

- **`refactor_student_analyzer_initial.py` -> `refactor_student_analyzer_final.py`**
  - **기존 코드**: 학생 데이터(딕셔너리)와 해당 데이터를 처리하는 로직(평균 계산, 최고 득점자 찾기)이 분리되어 있었습니다.
  - **리팩토링**: `StudentAnalyzer` 클래스를 만들어 학생 데이터와 관련 분석 기능을 하나의 단위로 묶었습니다.
  - **효과**: 데이터와 로직이 함께 있어 코드의 응집도가 높아지고, 재사용성이 향상되었습니다.

## 3. 클래스 내부 데이터 보호 (캡슐화)

- **`refactor_class_public_private.py`**
  - **기존 코드**: `BankAccount` 클래스의 잔액(balance) 속성에 외부에서 직접 접근하고 수정할 수 있었습니다.
  - **리팩토링**:
    - `_balance` 처럼 속성 이름 앞에 `_`를 붙여 내부에서만 사용함을 명시했습니다.
    - `deposit`, `withdraw`, `get_balance` 와 같은 공개 메서드(public method)를 통해서만 잔액에 접근하도록 변경했습니다.
  - **효과**: 의도치 않은 데이터 변경을 막아 객체의 상태를 안전하게 보호하고, 코드의 안정성을 높였습니다.

## 4. 코드 표현력 향상 (Pythonic Code)

- **`refactor_even_sum.py`**
  - **기존 코드**: `for` 루프와 `if` 조건문을 사용하여 짝수의 합을 구했습니다.
  - **리팩토링**: 리스트 컴프리헨션(List Comprehension)과 `sum()` 내장 함수를 사용하여 `sum([num for num in numbers if num % 2 == 0])` 와 같이 한 줄로 간결하게 표현했습니다.
  - **효과**: 코드가 짧아지고, "짝수만 골라서 합계를 구한다"는 의도가 더 명확하게 드러났습니다.

## 5. 데이터 처리 로직 개선

- **`refactor_product_data_clean.py`**: 상품 데이터에서 가격 정보가 누락된 경우를 처리하고, 데이터 타입을 정리하는 `clean_product_data` 함수를 통해 데이터 정제 로직을 명확한 함수로 분리했습니다.
- **`refactor_user_data_format.py`**: 여러 줄의 사용자 정보를 f-string을 사용하여 깔끔한 형식의 문자열로 만드는 `format_user_profile` 함수를 통해 복잡한 문자열 조합 로직을 개선했습니다.

## 종합

전반적으로 어제의 리팩토링 연습은 객체 지향의 핵심 원칙들을 적용하여 코드의 **유지보수성, 가독성, 안정성**을 높이는 데 중점을 두었습니다.
